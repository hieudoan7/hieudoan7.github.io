<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>hieudoan7</title>
    <link>https://hieudoan7.github.io/</link>
    <description>Recent content on hieudoan7</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 24 May 2021 10:40:47 +0700</lastBuildDate><atom:link href="https://hieudoan7.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>First_article</title>
      <link>https://hieudoan7.github.io/english/first_article/</link>
      <pubDate>Mon, 24 May 2021 10:40:47 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/english/first_article/</guid>
      <description>LOL 24/05/2021 This is the first article to help Hd7 improve his active english skill, ie writing and speaking not just passive english skill such as listening and reading. Yeah here we go, everystep (though small) make a huge impact in the future.</description>
    </item>
    
    <item>
      <title>Hieu test</title>
      <link>https://hieudoan7.github.io/others/test/</link>
      <pubDate>Sun, 23 May 2021 17:12:47 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/others/test/</guid>
      <description>Hieu test hugo to come back stronger yes here we go again
test insert image in hugo</description>
    </item>
    
    <item>
      <title>[Linux] Useful Commands</title>
      <link>https://hieudoan7.github.io/be/useful_command/</link>
      <pubDate>Thu, 25 Feb 2021 09:50:59 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/be/useful_command/</guid>
      <description>Useful Command Lines 25/02/2021
I. Cat Read a text-like file
Example:
$ cat file.txt | grep &amp;#34;pattern&amp;#34; | -A number_of_after_line -B number_of_before_line -C both_before_and_after_lines II. Find Find one or more files base on pattern
 return all the file and directory locate in a dir  $ find ~/Hd7/  return only file (or dir)  $ find ~/Hd7/ -type f or
$ find ~/Hd7/ -type d  return a file with specific name  $ find .</description>
    </item>
    
    <item>
      <title>Matrix Exponentiation</title>
      <link>https://hieudoan7.github.io/algos/matrix_exponentiation/</link>
      <pubDate>Wed, 22 Jan 2020 13:57:57 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/algos/matrix_exponentiation/</guid>
      <description>Matrix Exponentiation 22/01/2020
I. Linear Equation Đề bài: Giải hệ thức đệ quy:
$$\begin{cases}f_i = c_0 + c_1 f_{i-1} + c_2 f_{i-2} + &amp;hellip; + c_k f_{i-k}\\f_0, f_1, &amp;hellip;, f_{k-1}\end{cases}$$
Giải:
Ma trận xuất phát điểm: $F_k$ (k+1) x 1
$$\begin{bmatrix}f_0 \\f_1 \\ &amp;hellip;\\f_{k-1} \\1 \end{bmatrix} $$
Ma trận chuyển tiếp: (Transition) $T_{(k+1).(k+1)}$
$$\begin{bmatrix}0 &amp;amp; 1 &amp;amp; 0 &amp;amp; &amp;hellip; &amp;amp; 0 &amp;amp; 0 \\0 &amp;amp; 0 &amp;amp; 1 &amp;amp;&amp;hellip;&amp;amp; 0 &amp;amp; 0 \\ &amp;hellip; \\c_k &amp;amp; c_{k-1} &amp;amp; c_{k-2} &amp;amp; &amp;hellip; &amp;amp; c_1 &amp;amp; c_0\end{bmatrix}$$</description>
    </item>
    
    <item>
      <title>On the way to SEA VN</title>
      <link>https://hieudoan7.github.io/interview/sea/</link>
      <pubDate>Mon, 13 Jan 2020 18:41:14 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/interview/sea/</guid>
      <description>On the way to SEA VN 13/01/2020
Hôm nay mình rảnh nhân dịp nghỉ tết (19 âm lịch rồi) nên viết lại một chút quá trình phỏng vấn SEA VN để lưu lại, cũng như biết đâu giúp được 1 số bạn.
Quá trình phỏng vấn bao gồm 4 rounds
 Round 0: Làm bài test trên giấy Round 1: Face to Face technical interview 1 Round 2: Face to Face technical interview 2 Round 3: Yes/no round (:v)  I.</description>
    </item>
    
    <item>
      <title>Segment Tree</title>
      <link>https://hieudoan7.github.io/algos/segment_tree/</link>
      <pubDate>Sat, 28 Dec 2019 22:46:31 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/algos/segment_tree/</guid>
      <description>Segment Tree 28/12/2019
I. Mục đích: Giúp truy xuất giá trị trên 1 đoạn (segment) nhanh chóng và update giá trị nhanh chóng. Nhanh ở đây là $O(log\ n)$. Truy xuất ở đây có thể là tổng, phần tử nhỏ nhất, phần tử lớn nhất, &amp;hellip; .
II. Cấu tạo chung của 1 segment tree Xét một array $a[n]$ (từ $0..n-1$), ta build $1$ cái cây quản lý mảng a.</description>
    </item>
    
    <item>
      <title>Lowest Common Ancestor (LCA)</title>
      <link>https://hieudoan7.github.io/algos/lca/</link>
      <pubDate>Tue, 17 Dec 2019 14:48:39 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/algos/lca/</guid>
      <description>Lowest Common Ancestor (LCA) 17/12/2019
I. Bài toán Trả lời nhiều queries của bài toán tìm LCA 2 nodes u, v trong 1 rooted tree.
Lưu ý u, v phải nằm trong 1 cái tree, điều đó đảm bảo every nodes have only 1 parent (aka $2^0$-th parent).
II. Ý tưởng Có nhiều cách tìm LCA, mình sẽ trình bày cách phổ biến nhất có tên là binary raise (or binary lifting).</description>
    </item>
    
    <item>
      <title>Tree&#39;s Theorem</title>
      <link>https://hieudoan7.github.io/algos/tree_theorem/</link>
      <pubDate>Sat, 02 Nov 2019 23:12:30 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/algos/tree_theorem/</guid>
      <description>Tree&amp;rsquo;s Theorem 01/11/2019
I. Các cấu trúc cây cơ bản 1. Binary Tree Mỗi node trong cây có tối đa $2$ con.
2. Binary Search Tree Là Binary Tree + giá trị của node luôn lớn hơn giá trị của node con trái và bé hơn giá trị của node con phải.
3. AVL Tree (height balanced binary tree) Là self balancing Binary Search Tree + chênh lệch giữa cây con trái và cây con phải tại bất kì node nào luôn không vượt quá $1$.</description>
    </item>
    
    <item>
      <title>Sorting</title>
      <link>https://hieudoan7.github.io/algos/sorting/</link>
      <pubDate>Sat, 02 Nov 2019 14:11:28 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/algos/sorting/</guid>
      <description>Sorting Algorithm 02/11/2019
This post is going to give you some interesting algorithm ralating sorting elements.
Problem Sorting an array $a$ consists of $n$ elements in increasing order.
I. $O(n^2)$ Algorithm 1. Interchange Sort for(int i=0; i&amp;lt;n; i++){ for(int j=i+1; j&amp;lt;n; j++){ if (a[j] &amp;lt; a[i]) swap(a[j], a[i]); } } 2. Bubble Sort Từng phần tử nổi lên như bong bóng vậy đó.
for(int i=n-1; i&amp;gt;0; i--){ for(int j=1; j&amp;lt;=i; j++){ if (a[j] &amp;lt; a[j-1]) swap(a[j], a[j-1]); } } Ngoài ra còn có Insertion Sort, Selection Sort, Shaker Sort.</description>
    </item>
    
    <item>
      <title>Operator System</title>
      <link>https://hieudoan7.github.io/interview/operator_system/</link>
      <pubDate>Tue, 29 Oct 2019 23:11:03 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/interview/operator_system/</guid>
      <description>Operator System Questions for Interview 29/10/2019
Hệ điều hành là 1 chương trình quản lý phần cứng và cấp phát tài nguyên một cách phù hợp cho các chương trình.
I. Process (Tiến trình) 1. Tiến trình, tiểu trình? Tiến trình là một chương trình máy tính đang thực thi.
Tiểu trình (thread) là một đơn vị thực thi độc lập mà CPU có thể điều phối được. Thông thường, một Tiến trình gồm nhiều Tiểu trình.</description>
    </item>
    
    <item>
      <title>Computer Network</title>
      <link>https://hieudoan7.github.io/interview/computer_network/</link>
      <pubDate>Mon, 28 Oct 2019 21:27:43 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/interview/computer_network/</guid>
      <description>Computer Network Questions for Interview. 28/10/2019
1. DNS là gì, hoạt động như thế nào? DNS là Domain Name System: Hệ thống chuyển đổi domain name thành địa chỉ IP.
host: yahoo.com -&amp;gt; search catch -&amp;gt; miss -&amp;gt; Resolver (ISP or nhà cc mạng: VIETEL (người đại diên)) -&amp;gt; ROOT server -&amp;gt; .com server -&amp;gt; yahoo.com server -&amp;gt; đưa cho 1 IP server (rảnh) để mà về tải. Remark: DNS using port 53.</description>
    </item>
    
    <item>
      <title>All you need to know about Subset Sum Problem</title>
      <link>https://hieudoan7.github.io/algos/subset_sum/</link>
      <pubDate>Fri, 25 Oct 2019 20:14:31 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/algos/subset_sum/</guid>
      <description>All You need to know about Subset Sum Problem 25/10/2019
Bài toán:Cho 1 multiset $S = \{a_1, a_2, &amp;hellip;, a_n\}$, tìm 1 subset of $S$ thỏa điều kiện $P$.
Naive Solution: $\rightarrow O(2^n * n)$
Ta sinh tất cả các subset của $S$ $(O(2^n))$, sau đó duyệt qua từng subset $(O(n))$ để kiểm tra xem nó có thỏa điều kiện $P$ hay không.
Nó thực sự là 1 bài toán NP-Complete nên ta chỉ có thể giải trong thời gian exponential.</description>
    </item>
    
    <item>
      <title>Graph Traversal</title>
      <link>https://hieudoan7.github.io/algos/graph_traversal/</link>
      <pubDate>Thu, 12 Sep 2019 20:25:41 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/algos/graph_traversal/</guid>
      <description>Graph Traversal 12/09/2019
We discuss about the way we traverse a graph or a tree.
Assuming we are using adjacent list to represent a graph.
I. Depth-First Search (DFS) Idea: Đi sâu rồi quần lại.
1. Implement vector&amp;lt;int&amp;gt; g[N]; //or vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; g; bool vis[N]; void dfs(int v){ //vertex  vis[v] = true; for(auto u:g[v]){ //always for u =))  if (!vis[u]) dfs(u); } } //in main for(int i=0; i&amp;lt;n; i++){ if (!</description>
    </item>
    
    <item>
      <title>Minimum Spanning Tree</title>
      <link>https://hieudoan7.github.io/algos/minimum_spaning_tree/</link>
      <pubDate>Mon, 05 Aug 2019 20:25:45 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/algos/minimum_spaning_tree/</guid>
      <description>Minimum Spanning Tree (Cây khung nhỏ nhất)
05/08/2019
I. Definition  Tree: (Cây) là đồ thị vô hướng (undirected), liên thông (connected) và không có chu trình (acyclic).
Các tính chất của cây:  Cây n nodes luôn có n-1 cạnh Mỗi cạnh đều là cầu Thêm 1 cạnh bất kì sẽ tạo nên chu trình.   Spanning Tree: (Cây khung) là Cây chứa tất cả các nodes, so nó luôn có n-1 cạnh.</description>
    </item>
    
    <item>
      <title>Solving Recursive Sequence using Generating Function</title>
      <link>https://hieudoan7.github.io/algos/solving_recursive_using_generating_fuction/</link>
      <pubDate>Fri, 02 Aug 2019 22:11:07 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/algos/solving_recursive_using_generating_fuction/</guid>
      <description>Solving Recursive Sequence using Generating Function 02/08/2019
I. Definition Hàm sinh là cái hàm mà nén 1 dãy số $\{a_n\}, n\geq 0$ có quy luật thành một cái tổng $$\sum_{n=0}^\infty a_nx^n$$ Hệ số của $x^n$ chính là số hạng $a_n$ trong dãy $\{a_n\}, n\geq 0$.
II. Several Formulas Generating Function III. Solving Recursive Sequence. Examples: This example is my friend &amp;rsquo;s question in his interview, so I just note it. Ngoài ra còn có hàm sinh mũ cũng giải các hệ thức đệ quy phức tạp hơn.</description>
    </item>
    
    <item>
      <title>Articulation Point (Cut Point) &amp; Bridge</title>
      <link>https://hieudoan7.github.io/algos/ap_bridges/</link>
      <pubDate>Wed, 31 Jul 2019 22:01:16 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/algos/ap_bridges/</guid>
      <description>Articulation Point &amp;amp; Bridge 31/07/2019
I. Definition Ta xét trong undirected graph.
 Articulation Point (đỉnh khớp): Là đỉnh mà nếu cắt bỏ đi sẽ làm disconnect graph (trong connected graph) còn đối với disconnected graph thì nó làm tăng số connected component. Bridge: Là cạnh mà nếu bỏ đi &amp;hellip; (giống khớp)  II. Finding Articulation Point 1. Thuật toán tầm thường Với mỗi đỉnh trong graph, ta thử cắt bỏ đi và đếm số thành phần liên thông.</description>
    </item>
    
    <item>
      <title>Greatest Common Divisor using Eucidean Algorithm</title>
      <link>https://hieudoan7.github.io/algos/gcd_euclid/</link>
      <pubDate>Thu, 11 Jul 2019 21:49:24 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/algos/gcd_euclid/</guid>
      <description>Greatest Common Divisor using Euclidean Algorithm 11/07/2019
I. Implementation typedef long long ll; ll gcd (ll a, ll b){ return b==0? a : gcd(b, a%b); //phải hỏi b==0? chứ b=0 thì làm sao a chia dư 0 được. } II. Interpretation Thuật toán Euclid tìm ước chung lớn nhất giữa 2 số $a, b$.
Không mất tính tổng quát, giả sử $a &amp;gt; b$.
Nhìn hình, ta thấy, $gcd(a, b) = x$ khi và chỉ khi $x$ là ước của $a$, $x$ cũng là ước của $b$ và $x$ lớn nhất.</description>
    </item>
    
    <item>
      <title>KMP Algorithm</title>
      <link>https://hieudoan7.github.io/algos/kmp-algorithm/</link>
      <pubDate>Wed, 10 Jul 2019 22:42:22 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/algos/kmp-algorithm/</guid>
      <description>Knuth-Morris-Pratt algorithm 10/07/2019
I. Bài toán: Cho chuỗi Text $T$ (length = $n$) và Pattern $P$ (length = $m$). Tìm số lần xuất hiện của $P$ trong $T$.
$\Rightarrow$ Naive Solution:
Tại mỗi vị trí $i$ trong $T$, ta so sánh nó với $P$.
 code chơi thôi:
 int cnt = 0; for (int i = 0; i &amp;lt;= n-m; i++){ bool flag = false; for (int j = 0; j &amp;lt; m; j++){ if (P[j] == T[i+j]) continue; flag = true; break; } if (flag) cnt++; } $$\Rightarrow O(n*m) $$</description>
    </item>
    
    <item>
      <title>Floyd-Warshall Algorithm</title>
      <link>https://hieudoan7.github.io/algos/floyd-warshall_algorithm/</link>
      <pubDate>Tue, 09 Jul 2019 21:06:45 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/algos/floyd-warshall_algorithm/</guid>
      <description>Floyd-Warshall algorithm 09/07/2019
I. Mục đích All pair shortest path
Tìm đường đi ngắn nhất giữa tất cả các cặp đỉnh.
II. Ý tưởng: Quy hoạch động dựa vào đỉnh trung gian.
Với đỉnh trung gian đang xét là $k$, thì những $shortest\_path$ mà có các đỉnh trung gian thuộc $[1..k]$ sẽ được tìm thấy (kết quả cuối cùng luôn), còn những cái path kia thì có ngắn hơn nhưng chưa phải ngắn nhất vì nó còn đường ngắn hơn là đi qua đỉnh trung gian mà ta chưa cover tới.</description>
    </item>
    
    <item>
      <title>Dijkstra Algorithm</title>
      <link>https://hieudoan7.github.io/algos/dijistra_algorithm/</link>
      <pubDate>Tue, 09 Jul 2019 00:06:06 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/algos/dijistra_algorithm/</guid>
      <description>Dijkstra Algorithm 08/07/2019
I. Mục đích: Tìm đường đi ngắn nhất từ 1 node (starting node) đến tất cả các nodes còn lại.
Nhược điểm: Kết quả SAI khi đồ thị cạnh âm chứ chưa cần có mạch âm.
Ưu điểm: So với Bellman-ford, Dijistra hiệu quả hơn vì chỉ duyệt qua các cạnh đúng 1 lần.
II. Ý tưởng: Luôn lan truyền đến node gần nhất với starting node x.</description>
    </item>
    
    <item>
      <title>Bellman-Ford Algorithm</title>
      <link>https://hieudoan7.github.io/algos/bellman-ford_algorithm/</link>
      <pubDate>Mon, 08 Jul 2019 21:43:13 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/algos/bellman-ford_algorithm/</guid>
      <description>Bellman-Ford Algorithm 08/07/2019
I. Mục đích Tìm đường đi ngắn nhất từ 1 node (starting node) đến tất cả các nodes còn lại.
Ưu điểm: Có thể phát hiện mạch âm
II. Ý tưởng: Gọi $distance[i]$ là đường đi ngắn nhất từ đỉnh $x$ (starting node) đến đỉnh i ($distance[x] = 0$)
 Sau lần round 1: những đỉnh $i$ kề $x$ sẽ xác định được $distance[i]$ (final value luôn đó)</description>
    </item>
    
    <item>
      <title>Z-function</title>
      <link>https://hieudoan7.github.io/algos/z-function/</link>
      <pubDate>Sun, 07 Jul 2019 14:27:00 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/algos/z-function/</guid>
      <description>String Processing 18/04/2019
Cho 2 xâu P (pattern) và S (string). Mộ số bài toán
 Tìm vị trí xuất hiện đầu tiên của P trong S Đếm số lần xuất hiện P trong S Cho S, tìm P ngắn nhất để repeat P nhiều lần ta được S &amp;hellip;  I. Z-function 1. Định nghĩa Z-function Cho xâu $S = s[0..n-1]$.
Hàm $Z$ của xâu $S$ là dãy $z[0], z[1], &amp;hellip;, z[n-1]$ trong đó $z[i]$ là max (length) prefix của $s[i.</description>
    </item>
    
    <item>
      <title>Polish Notation</title>
      <link>https://hieudoan7.github.io/algos/polishnotation/</link>
      <pubDate>Sat, 29 Jun 2019 11:20:28 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/algos/polishnotation/</guid>
      <description>Polist Notation 29/06/2019
I. Kí pháp Balan là gì? (What is Polish Notation) Kí pháp Balan là một dạng viết khác của biểu thức toán học.
 Balan tiền tố (prefix): Đưa các toán tử lên đầu Balan ngược: Đưa các toán tử ra sau cùng  Trong kí pháp Balan, các dấu ngoặc bị lược bỏ
Ví dụ: Xét biểu thức: $3 + 5*(6-3) + 1$
 Balan: $ + + 3 * 5 - 6\ 3\ 1$ Balan ngược: $3\ 5\ 6\ 3 - * + 1 +$  Để xây dựng được kí pháp Balan, ta dùng cây biểu thức:</description>
    </item>
    
    <item>
      <title>Fenwick Tree - Binary Indexed Tree</title>
      <link>https://hieudoan7.github.io/algos/fenwicktree/</link>
      <pubDate>Tue, 25 Jun 2019 13:25:20 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/algos/fenwicktree/</guid>
      <description>Binary Indexed Tree (Fenwick Tree) 24/06/2019
Định nghĩa: Fenwick Tree (Binary Indexed Tree) là một CTDL với n node (n+1 nodes với node gốc bù nhìn) chứa thông tin (thường là tổng cộng dồn) về các phần tử trong đoạn (i-(i&amp;amp;-i), i] (mảng tính từ $1$)
 Nhận xét: Cây getSum vs cây Update khác nhau:  in GetSum: parent(i) = i-(i&amp;amp;-i) in Update: parent(i) = i+(i&amp;amp;-i)    Mục đích: Mục đích cây này là để tính range sum và khi update 1 phần tử trong mảng a thì các range sum involved cũng được update với chi phí thấp.</description>
    </item>
    
    <item>
      <title>Kosaraju&#39;s Algorithm Intuition</title>
      <link>https://hieudoan7.github.io/algos/kosaraju/</link>
      <pubDate>Tue, 18 Jun 2019 15:01:41 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/algos/kosaraju/</guid>
      <description>Kosaraju &amp;rsquo;s Algorithms 17/06/2019
I. DFS Tree Output của thuật toán DFS là 1 cây khung (spanning tree) Tất cả các cạnh của đồ thị gốc sẽ được chia làm 4 loại trong DFS spanning Tree:
 Tree Edge (sometimes Tree Edge được xếp vào Forward Edge) Forward Edge Back Edge Cross Edge  Example If the original graph is undirected then all of its edges are tree edge or black edge</description>
    </item>
    
    <item>
      <title>Hugo Tutorial</title>
      <link>https://hieudoan7.github.io/others/hugo-tutorial/</link>
      <pubDate>Fri, 19 Apr 2019 15:01:41 +0700</pubDate>
      
      <guid>https://hieudoan7.github.io/others/hugo-tutorial/</guid>
      <description>Hugo Tutorial 18.06.2019
I. Install Hugo &amp;amp; Setup Theme 2 best tutorial about hugo
part 1part 2
Về cơ bản, chúng ta host blog lên github sẽ tạo 2 repository
 Repo 1: hieudoan7: chứa các file config của hugo, content, nói chung tất tần tật. Repo 2: hieudoan7.github.io: repo này chứa file html để render lên web  Chú ý: dateformat trong file config.toml (ở thư mục gốc, thư mục mà ta có thể sử dụng hugo command) phải để ở ngày 2.</description>
    </item>
    
    <item>
      <title>The Fine Art of Small Talk</title>
      <link>https://hieudoan7.github.io/others/the-fine-art-of-small-talk/</link>
      <pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hieudoan7.github.io/others/the-fine-art-of-small-talk/</guid>
      <description>Small Talk Note 05/04/2019
Em học được gì qua nội dung quyển sách? Contents  Chapter 1: What&amp;rsquo;s Big Deal About Small Talk? Chapter 2: Get Over Your Mom &amp;rsquo;s Intentions Chapter 3: Take the Plunge: Start a Conversation! Chapter 4: Keep the Conservation Going! Chapter 5: Let&amp;rsquo;s Give &amp;lsquo;Em Something to Talk About Chapter 6: Hearing Aids and Listening Devices Chapter 7: Prevent Pregmant Pauses with Preparationg Chapter 8: Conservation Clout Chapter 9: Crimes and Misdemeanors Chapter 10: The Graceful Exit Chapter 11: The Conservation Ball Is in Your Court!</description>
    </item>
    
    <item>
      <title>About me</title>
      <link>https://hieudoan7.github.io/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hieudoan7.github.io/about/</guid>
      <description>I am Hieu Doan Minh  Hello everyone, my name is Hieu. I come from Binh Dinh province, Vietnam. I study computer science in HCMUS. I would love to think about code and solve problems. I like playing football, watching football matches and chess, listening to music too. I am also kind of humour. If you want to make friend with me, don&amp;rsquo;t hesitate to ping me!!! It would be highly appreciated.</description>
    </item>
    
  </channel>
</rss>
